---
title: "EDX Capstone Project"
author: Mark145
date: Fall 2019
output: 
  pdf_document:
    toc: true
    #number_selections: true
fontsize: 12pt
geometry: margin=1in
---

#Introduction

Weather balloons are deployed world wide every day.  The data collected from each balloon is stored by the National Oceanic and Atmospheric Administration (NOAA), an American scientific agency within the United States Department of Commerce.

NOAA produces the raw and derieved (scientific calculations base on raw) data for public use and makes the data availiabe within NOAA's Integrated Global Radiosonde Archive (IGRA).  The IGRA website is
https://www.ncdc.noaa.gov/data-access/weather-balloon/integrated-global-radiosonde-archive

#Overview

The model contained within this report seeks to predict temperature for any given altitude at any given day of a year.  The data is sourced from radioscondes and available for public use via NOAA's website.  The training and test data will focus on all the data produced by the UAE at Abu Dhabi International Airport.

Root Mean Square Error (RMSE) will be used to report the error this algorithm produces.  Our base altitude will contain data for 1000m +/- 100m.  First, error will be calculated by guessing the average temperature for the base altitude given a day.  Secondly, error will be calculated by incorporating the previous day's temperature for 1000m +/- 100m and regressing to the mean for the predicted day.  

#Executive Summary

The model generated below, computes the average temperature for a given altitude block and associates that average to unique Month Day.  It then applies that average to the predicted Month Day and computes the RMSE.  The RMSE generated by this model is ~3.2*C.

#Methods/Analysis

The following packages/libraries are used for analysis.
```{r, library check and load}
if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(data.table)) install.packages("data.table", repos = "http://cran.us.r-project.org")
if(!require(sf)) install.packages("sf", repos = "http://cran.us.r-project.org")
if(!require(rgeos)) install.packages("rgeos", repos = "http://cran.us.r-project.org")
if(!require(rnaturalearth)) install.packages("rnaturalearth", repos = "http://cran.us.r-project.org")
if(!require(rnaturalearthdata)) install.packages("rnaturalearthdata", repos = "http://cran.us.r-project.org")
if(!require(ggspatial)) install.packages("ggspatial", repos = "http://cran.us.r-project.org")
```


The following script will will reach into NOAA's IGRA file space and pull the data stored from the United Arab Emraites' Abu Dhabi International Airport station as well as Quatar's Hamad International Airport which will be used during exploration.  Also used for exploration, is the station list data generated by NOAA.  The data is then parsed and formatted for each record to represent one recorded reading of the weather balloon sensor.
```{r, download and parse the data}
#downloading period of record (-por) vice year to date (-ytd) for UAE and Quatar 
#downloading station list file
AE <- tempfile()
download.file("https://www1.ncdc.noaa.gov/pub/data/igra/derived/derived-por/AEM00041217-drvd.txt.zip", AE)
uaeDat <- unzip(AE, "AEM00041217-drvd.txt")

QA <- tempfile()
download.file("https://www1.ncdc.noaa.gov/pub/data/igra/derived/derived-por/QAM00041169-drvd.txt.zip", QA)
quatarDat <- unzip(QA, "QAM00041169-drvd.txt")

statList <- tempfile()
download.file("https://www1.ncdc.noaa.gov/pub/data/igra/igra2-station-list.txt", statList)

#function to parse out the headers
v2_drvd_header_parser <- function(file, ...) {
  readr::read_fwf(
    file = file,
    col_positions = readr::fwf_positions(
      c(1, 2, 14, 19, 22, 25, 28, 32, 38, 44, 50, 56, 62, 68, 74, 80, 86, 92, 98, 104, 110, 116, 122, 128, 134, 140, 146, 152),
      c(1, 12, 17, 20, 23, 26, 31, 36, 43, 49, 55, 61, 67, 73, 79, 85, 91, 97, 103, 109, 115, 121, 127, 133, 139, 145, 151, 157),
      c("HEADREC", "ID", "YEAR", "MONTH", "DAY", "HOUR", "RELTIME", "NUMLEV", "PW", "INVPRESS", "INVHGT", "INVTEMPDIF", "MIXPRESS", "MIXHGT", "FRZPRESS", "FRZHGT", "LCLPRESS", "LCLHGT", "LFCPRESS", "LFCHGT", "LNBPRESS", "LNBHGT", "LI", "SI", "KI", "TTI", "CAPE", "CIN")
    ),
    col_types = readr::cols(
      HEADREC = readr::col_character(),
      ID = readr::col_character(),
      YEAR = readr::col_integer(),
      MONTH = readr::col_integer(),
      DAY = readr::col_integer(),
      HOUR = readr::col_integer(),
      RELTIME = readr::col_integer(),
      NUMLEV = readr::col_integer(),
      PW = readr::col_integer(),
      INVPRESS = readr::col_integer(),
      INVHGT = readr::col_integer(),
      INVTEMPDIF = readr::col_integer(),
      MIXPRESS = readr::col_integer(),
      MIXHGT = readr::col_integer(),
      FRZPRESS = readr::col_integer(),
      FRZHGT = readr::col_integer(),
      LCLPRESS = readr::col_integer(),
      LCLHGT = readr::col_integer(),
      LFCPRESS = readr::col_integer(),
      LFCHGT = readr::col_integer(),
      LNBPRESS = readr::col_integer(),
      LNBHGT = readr::col_integer(),
      LI = readr::col_integer(),
      SI = readr::col_integer(),
      KI = readr::col_integer(),
      TTI = readr::col_integer(),
      CAPE = readr::col_integer(),
      CIN = readr::col_integer()
    )
  )
}

#function to parse out the data
v2_drvd_data_parser <- function(file, ...) {
  readr::read_fwf(
    file = file,
    col_positions = readr::fwf_positions(
      c(1, 9, 17, 25, 33, 41, 49, 57, 65, 73, 81, 89, 97, 105, 113, 121, 129, 137, 145),
      c(7, 15, 23, 31, 39, 47, 55, 63, 71, 79, 87, 95, 103, 111, 119, 127, 135, 143, 151),
      c("PRESS", "REPGPH", "CALCGPH", "TEMP", "TEMPGRAD", "PTEMP", "PTEMPGRAD", "VTEMP", "VPTEMP", "VAPPRESS", "SATVAP", "REPRH", "CALCRH", "RHGRAD", "UWND", "UWDGRAD", "VWND", "VWNDGRAD", "N")
    ),
    col_types = readr::cols(
      PRESS = readr::col_integer(),
      REPGPH = readr::col_integer(),
      CALCGPH = readr::col_integer(),
      TEMP = readr::col_integer(),
      TEMPGRAD = readr::col_integer(),
      PTEMP = readr::col_integer(),
      PTEMPGRAD = readr::col_integer(),
      VTEMP = readr::col_integer(),
      VPTEMP = readr::col_integer(),
      VAPPRESS = readr::col_integer(),
      SATVAP = readr::col_integer(),
      REPRH = readr::col_integer(),
      CALCRH = readr::col_integer(),
      RHGRAD = readr::col_integer(),
      UWND = readr::col_integer(),
      UWDGRAD = readr::col_integer(),
      VWND = readr::col_integer(),
      VWNDGRAD = readr::col_integer(),
      N = readr::col_integer()
    ),
    comment = '#'
  )
}

#function to id the headers
is_header <- function(line0){
  substr(line0, 1, 1) == '#'
}

#function to parse station list
stations_parser <- function(file, ...) {
  readr::read_fwf(
    file = file,
    col_positions = readr::fwf_positions(
      c(1,13,22,32,39,42,73,78,83),
      c(11,20,30,37,40,71,76,81,88),
      c("ID","LATITUDE","LONGITUDE","ELEVATION","STATE","NAME","FSTYEAR","LSTYEAR","NOBS")
    ),
    col_types = readr::cols(
      ID = readr::col_character(),
      LATITUDE = readr::col_number(),
      LONGITUDE = readr::col_number(),
      ELEVATION = readr::col_number(),
      STATE = readr::col_character(),
      NAME = readr::col_character(),
      FSTYEAR = readr::col_integer(),
      LSTYEAR = readr::col_integer(),
      NOBS = readr::col_integer()
    )
  )
}

#function to parse everything into temp files
parse_IGRA <- function(file, header_parser, data_parser) {
  # Parsing the file
  cat("Parsing the file...")
  data0 <- data_parser(file)
  
  # Parsing and inserting the metadata separately
  lines <- readLines(file)
  header_flag <- sapply(lines, is_header)
  header_lines <- lines[header_flag]
  header_coverage <- table(cumsum(as.numeric(header_flag)))
  
  # Create temporary file for the header lines
  temp_file <- tempfile()
  write(header_lines, file = temp_file)
  metadata0 <- header_parser(temp_file)
  file.remove(temp_file)
  
  metadata <- dplyr::bind_rows(purrr::map2(
    1:nrow(metadata0), header_coverage,
    function(i, times) {
      metadata0[rep(i, times - 1), ]
    }
  ))
  
  cat("Done! \n")
  dplyr::bind_cols(metadata, data0)
}

#call to implement functions above on UAE and Quatar data and combine them
UAE <- parse_IGRA(uaeDat, v2_drvd_header_parser, v2_drvd_data_parser)[, -1]
QUATAR <- parse_IGRA(quatarDat, v2_drvd_header_parser, v2_drvd_data_parser)[, -1]
df <- rbind(UAE, QUATAR)

#call to parse station list
stations <- stations_parser(statList)

#cleaning up the environment
rm(uaeDat,quatarDat,AE,QA,is_header,parse_IGRA,v2_drvd_data_parser,
   v2_drvd_header_parser, QUATAR, UAE, stations_parser, statList)
file.remove("AEM00041217-drvd.txt","QAM00041169-drvd.txt")


```

From the chart below, we can see the current reporting locations for all radiosconde deployments worldwide, which are tracked and avaliable by NOAA.

```{r, world-wide station plot}
plot_stations <- st_as_sf(stations %>% filter(LSTYEAR == 2019, ELEVATION != -998.8), coords = c("LONGITUDE","LATITUDE"), crs = 4326, agr = "constant")

world <- ne_countries(scale = "medium", returnclass = "sf")
currentStatNum <- stations %>% filter(LSTYEAR == 2019) %>% tally()

ggplot(data = world) +
  geom_sf() +
  geom_sf(data = plot_stations, size = 1, shape = 23, fill = "darkred")+
  ggtitle("Worldwide Radiosconde Launch Stations")
```

Now a plot for all the reporting stations near our training and test data, UAE.

```{r, mid-east station plot}
ggplot(data = world) +
  geom_sf() +
  geom_sf(data = plot_stations, size = 3, shape = 23, fill = "darkred")+
  coord_sf(xlim = c(45, 65), ylim = c(18, 32), expand = FALSE) +
  ggtitle("Radiosconde Launch Stations Around The UAE")
```

Now lets look at the temperature data for the UAE site and how it compares to the station in Quatar.  The data found in both plots is derived from the first day of each month and a launch time of 1200 UTC.

```{r, temp vs. alt UAE}
df %>% group_by(DAY) %>%
  filter(HOUR == 12 & DAY == 1) %>%
  ggplot(aes(x = ((TEMP/10)-272.15), y= (CALCGPH))) +
  geom_point(aes(col=MONTH)) +
  facet_grid(ID ~ .)+
  ylab("Altitude (meters)") +
  xlab("Temperature (degrees of celcius)")
```

Here is a plot adjustment, with all the UAE data, for the altitude we are attempting to predict.
```{r}
df %>% 
  filter(ID == "AEM00041217") %>%
  ggplot(aes(x = ((TEMP/10)-272.15), y= (CALCGPH))) +
  geom_point(aes(col=MONTH)) +
  ylab("Altitude (meters)") +
  xlab("Temperature (degrees of celcius)") +
  ylim(900,1100) +
  xlim(5,45)+
  ggtitle("UAE Data for the 1st of Every Month Since 1984")
```

As depected above, the winter months (lightest and darkest blue) have lower temperatures while the summer (blended blue) have warmer temperatures.

Algorithm Development

The code below will clean up the environment and generate a training and validation set.
```{r, environment cleanup and find working data}
training_df <- df %>% filter(ID == "AEM00041217" & CALCGPH > 900 & CALCGPH <1100 & HOUR == 0)
training_df <- training_df %>% mutate(monthDay = paste(MONTH,DAY)) %>% mutate(tempC = (TEMP/10)-272.15)

validation_df <- df %>% filter(ID == "AEM00041217" & CALCGPH > 900 & CALCGPH <1100 & HOUR == 12)
validation_df <- validation_df %>% mutate(monthDay = paste(MONTH,DAY)) %>% mutate(tempC = (TEMP/10)-272.15)
rm(currentStatNum, df, plot_stations, stations, world)
```

Our training data will be the 0 UTC hour launches and our validation/test data will be the 12 UTC launches.

The check function, how well we did will be computed by 'root mean square error' (RMSE).  We will find the difference for each days temperature rating at this layer, to what was actually measured at the layer.  Then square this value and average it for all days with measurements.  Lastly, we will find the square root of that average and report the value.  A value of 1 means 1 degree of celcius off from reality.

```{r, RMSE function}
RMSE <- function(training_df, predicted_temperature){
  sqrt(mean((training_df - predicted_temperature)^2))
}
```

There are a couple of ways of determining the same time every year.  One method would be to convert the date to a number 1-365 and group all of the same numbers throughout the year.  Perhaps the most accurate way to identify the same time each year would be the incorporation of celiestial bodies.  For the sake of this model, I will group by Month Day and calculate the average temperature.

```{r, group by day calc mean}
daily_mu <- training_df %>%
  group_by(monthDay) %>%
  summarize(mu = mean(TEMP)) %>%
  mutate(mu = (mu/10)-272.15)
```

```{r}
training_df <- left_join(training_df, daily_mu)
```

The RMSE for predicting the average daily temperature is 2.79*C on our training data.

```{r}
RMSE(training_df$tempC, training_df$mu)
```

#Modeling Results

Now the daily average for UTC(0) will be applied to the validation set UTC(12).  
```{r}
validation_df <- left_join(validation_df, daily_mu)
RMSE(validation_df$tempC, validation_df$mu)
```

We can see that our RMSE increased to ~3.2*C.  

#Conclusion and Future Work

Our RMSE increased when we applied the derieved mean temperature to each record.  This was likely due to the variance in temperature when measuring at different times during the day.

Future model development should acount for all times of the day and some sort of historisis.  Perhaps the previous day's average temperature or the previous altitude block's average temperature.









